import React, { useEffect , useState } from 'react';

const Intersection = (props) => {
    
    const [data, setData ] = useState([]);
    const [requested, setRequested] = useState(false);
    const blueprint = props.blueprint;
    const resource = "http://127.0.0.1:5000/" + props.name + "/" + props.simulationType
    
    
    
    useEffect( () => {
	/* Only request data from trafficSimulator if we change the simulation type */
	if (requested===props.simulationType) {return;}
	setRequested(props.simulationType);
	fetch(resource).then(
	    /* extract data from response and pass it on */
	    (response) => {
		return response.json();
	    }).then(
		/* Update state of "data" */
		(jsonData) => {
		    /* Merge traffic data with blueprint data */
		    /* TODO: Fix ugly nesting of map */
		    const temp = blueprint.streets
					  .map( street => {
					      return {...street, lanes:street.lanes.map( lane => {
						  return {[lane]:jsonData[lane]};
					      })};
					  });
		    setData(temp);
		});
    }, [props.simulationType, blueprint.streets, requested, resource]); 

    /* Create Street components if there's data */
    const Streets = data ? data.map(street =>
	(
	    <Street key={props.name+street.rotation}
		    id={props.name+street.rotation}
		    rotation={street.rotation}
		    lanes={street.lanes}
		    x={blueprint.x}
		    y={blueprint.y}
	    /> )
    ): null;
    
    /* Nest the intersection in a its own group */
    return (
	<g className="intersection">
	    { <text x={blueprint.x} y={blueprint.y}>{props.name}</text> }
	    { Streets ? Streets : null }
	</g>
    )
};

/* Handle visualization of a group of lanes */ 
const Street = (props) => {
    
    const lanes = props.lanes.map( (lane,idx) =>
	(
	    <g key={props.id+idx}>	    
	        <Lane key={Object.keys(lane)[0]}
	              cars={Object.values(lane)[0]}
	              x={props.x}
	              y={props.y}
	              offset={idx}
	        />
		
	    </g>
	));
    
    const rotation = `rotate(${props.rotation},${props.x + 1},${props.y + 1})`;
    
    return (
	<g transform={rotation}>
	    { lanes }
	</g>
    )
};

/* A lane is represented by a rectangle. */
const Lane = (props) => {
    return (
	<rect
	    className="lane"
	    fill={carsToColor(props.cars)}
	    width="1"
	    height="30"
	    x={props.x + props.offset}
	    y={props.y}/>
    )
};

/* no cars=green, 50 cars=yellow, 100+ cars=red. Grey if there's no data.*/
const carsToColor = (cars) => {
    if (!cars) return "grey"
    var R;
    var G;
    var B = 0;
    var value = Math.min(255,parseInt(cars*5.1));
    if (cars < 50) {R = value; G = 255;}
    else if (cars > 50) {R=255; G = 255-value;}
    else {R=255;G=255}
    return `RGB(${R},${G},${B})`
}

export default Intersection;
